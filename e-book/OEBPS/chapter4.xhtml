<?xml version="1.0" encoding="UTF-8" standalone="no" ?><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/>
<link href="styles/zstylesheet.css" rel="stylesheet" type="text/css"/>
<title>Chapter 4</title>
</head>

<body>

	<h1 class="heading">Chapter 4 – Slide Puzzle</h1>
	<hr class="heading"/>

	<h1 class="subheading" id="how-to-play">How to Play Slide Puzzle</h1>
	<p class="noindent">The board is a 4×4 grid with fifteen tiles (numbered 1 through 15 going left to right) and one blank space. The tiles start out in random positions, and the player must slide tiles around until the tiles are back in their original order.</p>

	<h1 class="subheading" id="source-code">Source Code for Slide Puzzle</h1>
	<p class="noindent">This source code can be downloaded from <a href="https://invpy.com/slidepuzzle.py">https://invpy.com/slidepuzzle.py</a>. If you get any error messages, look at the line number that is mentioned in the error message and check your code for any typos. You can also copy and paste your code into the web form at <a href="https://invpy.com/diff/slidepuzzle">https://invpy.com/diff/slidepuzzle</a> to see if the differences between your code and the code in the book.</p>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;&#160;1.</span> <span class="comment"># Slide Puzzle</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;2.</span> <span class="comment"># By Al Sweigart al@inventwithpython.com</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;3.</span> <span class="comment"># http://inventwithpython.com/pygame</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;4.</span> <span class="comment"># Creative Commons BY-NC-SA 3.0 US</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;5.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;6.</span> import pygame, sys, random</p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;7.</span> from pygame.locals import *</p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;8.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;9.</span> <span class="comment"># Create the constants (go ahead and experiment with different values)</span></p>
		<p class="noindent mono"><span class="line-number">&#160;10.</span> BOARDWIDTH = 4  <span class="comment"># number of columns in the board</span></p>
		<p class="noindent mono"><span class="line-number">&#160;11.</span> BOARDHEIGHT = 4 <span class="comment"># number of rows in the board</span></p>
		<p class="noindent mono"><span class="line-number">&#160;12.</span> TILESIZE = 80</p>
		<p class="noindent mono"><span class="line-number">&#160;13.</span> WINDOWWIDTH = 640</p>
		<p class="noindent mono"><span class="line-number">&#160;14.</span> WINDOWHEIGHT = 480</p>
		<p class="noindent mono"><span class="line-number">&#160;15.</span> FPS = 30</p>
		<p class="noindent mono"><span class="line-number">&#160;16.</span> BLANK = None</p>
		<p class="noindent mono"><span class="line-number">&#160;17.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;18.</span> <span class="comment"># &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R&#160;&#160;&#160;&#160;G&#160;&#160;&#160;&#160;B</span></p>
		<p class="noindent mono"><span class="line-number">&#160;19.</span> BLACK = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#160;&#160;0, &#160;&#160;0, &#160;&#160;0)</p>
		<p class="noindent mono"><span class="line-number">&#160;20.</span> WHITE = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(255, 255, 255)</p>
		<p class="noindent mono"><span class="line-number">&#160;21.</span> BRIGHTBLUE = &#160;&#160;&#160;(&#160;&#160;0, &#160;50, 255)</p>
		<p class="noindent mono"><span class="line-number">&#160;22.</span> DARKTURQUOISE = (&#160;&#160;3, &#160;54, &#160;73)</p>
		<p class="noindent mono"><span class="line-number">&#160;23.</span> GREEN = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#160;&#160;0, 204, &#160;&#160;0)</p>
		<p class="noindent mono"><span class="line-number">&#160;24.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;25.</span> BGCOLOR = DARKTURQUOISE</p>
		<p class="noindent mono"><span class="line-number">&#160;26.</span> TILECOLOR = GREEN</p>
		<p class="noindent mono"><span class="line-number">&#160;27.</span> TEXTCOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;28.</span> BORDERCOLOR = BRIGHTBLUE</p>
		<p class="noindent mono"><span class="line-number">&#160;29.</span> BASICFONTSIZE = 20</p>
		<p class="noindent mono"><span class="line-number">&#160;30.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;31.</span> BUTTONCOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;32.</span> BUTTONTEXTCOLOR = BLACK</p>
		<p class="noindent mono"><span class="line-number">&#160;33.</span> MESSAGECOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;34.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;35.</span> XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / 2)</p>
		<p class="noindent mono"><span class="line-number">&#160;36.</span> YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - 1))) / 2)</p>
		<p class="noindent mono"><span class="line-number">&#160;37.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;38.</span> UP = 'up'</p>
		<p class="noindent mono"><span class="line-number">&#160;39.</span> DOWN = 'down'</p>
		<p class="noindent mono"><span class="line-number">&#160;40.</span> LEFT = 'left'</p>
		<p class="noindent mono"><span class="line-number">&#160;41.</span> RIGHT = 'right'</p>
		<p class="noindent mono"><span class="line-number">&#160;42.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;43.</span> def main():</p>
		<p class="noindent mono"><span class="line-number">&#160;44.</span> &#160;&#160;&#160;&#160;global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, NEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT</p>
		<p class="noindent mono"><span class="line-number">&#160;45.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;46.</span> &#160;&#160;&#160;&#160;pygame.init()</p>
		<p class="noindent mono"><span class="line-number">&#160;47.</span> &#160;&#160;&#160;&#160;FPSCLOCK = pygame.time.Clock()</p>
		<p class="noindent mono"><span class="line-number">&#160;48.</span> &#160;&#160;&#160;&#160;DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))</p>
		<p class="noindent mono"><span class="line-number">&#160;49.</span> &#160;&#160;&#160;&#160;pygame.display.set_caption('Slide Puzzle')</p>
		<p class="noindent mono"><span class="line-number">&#160;50.</span> &#160;&#160;&#160;&#160;BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE)</p>
		<p class="noindent mono"><span class="line-number">&#160;51.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;52.</span> &#160;&#160;&#160;&#160;<span class="comment"># Store the option buttons and their rectangles in OPTIONS.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;53.</span> &#160;&#160;&#160;&#160;RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 90)</p>
		<p class="noindent mono"><span class="line-number">&#160;54.</span> &#160;&#160;&#160;&#160;NEW_SURF, NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 60)</p>
		<p class="noindent mono"><span class="line-number">&#160;55.</span> &#160;&#160;&#160;&#160;SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 30)</p>
		<p class="noindent mono"><span class="line-number">&#160;56.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;57.</span> &#160;&#160;&#160;&#160;mainBoard, solutionSeq = generateNewPuzzle(80)</p>
		<p class="noindent mono"><span class="line-number">&#160;58.</span> &#160;&#160;&#160;&#160;SOLVEDBOARD = getStartingBoard() <span class="comment"># a solved board is the same as the board in a start state.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;59.</span> &#160;&#160;&#160;&#160;allMoves = [] <span class="comment"># list of moves made from the solved configuration</span></p>
		<p class="noindent mono"><span class="line-number">&#160;60.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;61.</span> &#160;&#160;&#160;&#160;while True: <span class="comment"># main game loop</span></p>
		<p class="noindent mono"><span class="line-number">&#160;62.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = None <span class="comment"># the direction, if any, a tile should slide</span></p>
		<p class="noindent mono"><span class="line-number">&#160;63.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg = '' <span class="comment"># contains the message to show in the upper left corner.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;64.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if mainBoard == SOLVEDBOARD:</p>
		<p class="noindent mono"><span class="line-number">&#160;65.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg = 'Solved!'</p>
		<p class="noindent mono"><span class="line-number">&#160;66.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;67.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawBoard(mainBoard, msg)</p>
		<p class="noindent mono"><span class="line-number">&#160;68.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;69.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;checkForQuit()</p>
		<p class="noindent mono"><span class="line-number">&#160;70.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for event in pygame.event.get(): <span class="comment"># event handling loop</span></p>
		<p class="noindent mono"><span class="line-number">&#160;71.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if event.type == MOUSEBUTTONUP:</p>
		<p class="noindent mono"><span class="line-number">&#160;72.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;spotx, spoty = getSpotClicked(mainBoard, event.pos[0], event.pos[1])</p>
		<p class="noindent mono"><span class="line-number">&#160;73.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;74.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (spotx, spoty) == (None, None):</p>
		<p class="noindent mono"><span class="line-number">&#160;75.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># check if the user clicked on an option button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;76.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if RESET_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;77.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resetAnimation(mainBoard, allMoves) <span class="comment"># clicked on Reset button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;78.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
		<p class="noindent mono"><span class="line-number">&#160;79.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif NEW_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;80.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mainBoard, solutionSeq = generateNewPuzzle(80) <span class="comment"># clicked on New Game button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;81.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
		<p class="noindent mono"><span class="line-number">&#160;82.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif SOLVE_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;83.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resetAnimation(mainBoard, solutionSeq + allMoves) <span class="comment"># clicked on Solve button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;84.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
		<p class="noindent mono"><span class="line-number">&#160;85.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:</p>
		<p class="noindent mono"><span class="line-number">&#160;86.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># check if the clicked tile was next to the blank spot</span></p>
		<p class="noindent mono"><span class="line-number">&#160;87.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;88.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;blankx, blanky = getBlankPosition(mainBoard)</p>
		<p class="noindent mono"><span class="line-number">&#160;89.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if spotx == blankx + 1 and spoty == blanky:</p>
		<p class="noindent mono"><span class="line-number">&#160;90.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = LEFT</p>
		<p class="noindent mono"><span class="line-number">&#160;91.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif spotx == blankx - 1 and spoty == blanky:</p>
		<p class="noindent mono"><span class="line-number">&#160;92.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = RIGHT</p>
		<p class="noindent mono"><span class="line-number">&#160;93.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif spotx == blankx and spoty == blanky + 1:</p>
		<p class="noindent mono"><span class="line-number">&#160;94.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = UP</p>
		<p class="noindent mono"><span class="line-number">&#160;95.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif spotx == blankx and spoty == blanky - 1:</p>
		<p class="noindent mono"><span class="line-number">&#160;96.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = DOWN</p>
		<p class="noindent mono"><span class="line-number">&#160;97.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;98.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif event.type == KEYUP:</p>
		<p class="noindent mono"><span class="line-number">&#160;99.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># check if the user pressed a key to slide a tile</span></p>
		<p class="noindent mono"><span class="line-number">100.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):</p>
		<p class="noindent mono"><span class="line-number">101.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = LEFT</p>
		<p class="noindent mono"><span class="line-number">102.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):</p>
		<p class="noindent mono"><span class="line-number">103.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = RIGHT</p>
		<p class="noindent mono"><span class="line-number">104.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):</p>
		<p class="noindent mono"><span class="line-number">105.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = UP</p>
		<p class="noindent mono"><span class="line-number">106.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):</p>
		<p class="noindent mono"><span class="line-number">107.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = DOWN</p>
		<p class="noindent mono"><span class="line-number">108.</span></p>
		<p class="noindent mono"><span class="line-number">109.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if slideTo:</p>
		<p class="noindent mono"><span class="line-number">110.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideAnimation(mainBoard, slideTo, 'Click tile or press arrow keys to slide.', 8) <span class="comment"># show slide on screen</span></p>
		<p class="noindent mono"><span class="line-number">111.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;makeMove(mainBoard, slideTo)</p>
		<p class="noindent mono"><span class="line-number">112.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves.append(slideTo) <span class="comment"># record the slide</span></p>
		<p class="noindent mono"><span class="line-number">113.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">114.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FPSCLOCK.tick(FPS)</p>
		<p class="noindent mono"><span class="line-number">115.</span></p>
		<p class="noindent mono"><span class="line-number">116.</span></p>
		<p class="noindent mono"><span class="line-number">117.</span> def terminate():</p>
		<p class="noindent mono"><span class="line-number">118.</span> &#160;&#160;&#160;&#160;pygame.quit()</p>
		<p class="noindent mono"><span class="line-number">119.</span> &#160;&#160;&#160;&#160;sys.exit()</p>
		<p class="noindent mono"><span class="line-number">120.</span></p>
		<p class="noindent mono"><span class="line-number">121.</span></p>
		<p class="noindent mono"><span class="line-number">122.</span> def checkForQuit():</p>
		<p class="noindent mono"><span class="line-number">123.</span> &#160;&#160;&#160;&#160;for event in pygame.event.get(QUIT): <span class="comment"># get all the QUIT events</span></p>
		<p class="noindent mono"><span class="line-number">124.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;terminate() <span class="comment"># terminate if any QUIT events are present</span></p>
		<p class="noindent mono"><span class="line-number">125.</span> &#160;&#160;&#160;&#160;for event in pygame.event.get(KEYUP): <span class="comment"># get all the KEYUP events</span></p>
		<p class="noindent mono"><span class="line-number">126.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if event.key == K_ESCAPE:</p>
		<p class="noindent mono"><span class="line-number">127.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;terminate() <span class="comment"># terminate if the KEYUP event was for the Esc key</span></p>
		<p class="noindent mono"><span class="line-number">128.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pygame.event.post(event) <span class="comment"># put the other KEYUP event objects back</span></p>
		<p class="noindent mono"><span class="line-number">129.</span></p>
		<p class="noindent mono"><span class="line-number">130.</span></p>
		<p class="noindent mono"><span class="line-number">131.</span> def getStartingBoard():</p>
		<p class="noindent mono"><span class="line-number">132.</span> &#160;&#160;&#160;&#160;<span class="comment"># Return a board data structure with tiles in the solved state.</span></p>
		<p class="noindent mono"><span class="line-number">133.</span> &#160;&#160;&#160;&#160;<span class="comment"># For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function</span></p>
		<p class="noindent mono"><span class="line-number">134.</span> &#160;&#160;&#160;&#160;<span class="comment"># returns [[1, 4, 7], [2, 5, 8], [3, 6, None]]</span></p>
		<p class="noindent mono"><span class="line-number">135.</span> &#160;&#160;&#160;&#160;counter = 1</p>
		<p class="noindent mono"><span class="line-number">136.</span> &#160;&#160;&#160;&#160;board = []</p>
		<p class="noindent mono"><span class="line-number">137.</span> &#160;&#160;&#160;&#160;for x in range(BOARDWIDTH):</p>
		<p class="noindent mono"><span class="line-number">138.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;column = []</p>
		<p class="noindent mono"><span class="line-number">139.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for y in range(BOARDHEIGHT):</p>
		<p class="noindent mono"><span class="line-number">140.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;column.append(counter)</p>
		<p class="noindent mono"><span class="line-number">141.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;counter += BOARDWIDTH</p>
		<p class="noindent mono"><span class="line-number">142.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board.append(column)</p>
		<p class="noindent mono"><span class="line-number">143.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1</p>
		<p class="noindent mono"><span class="line-number">144.</span></p>
		<p class="noindent mono"><span class="line-number">145.</span> &#160;&#160;&#160;&#160;board[BOARDWIDTH-1][BOARDHEIGHT-1] = None</p>
		<p class="noindent mono"><span class="line-number">146.</span> &#160;&#160;&#160;&#160;return board</p>
		<p class="noindent mono"><span class="line-number">147.</span></p>
		<p class="noindent mono"><span class="line-number">148.</span></p>
		<p class="noindent mono"><span class="line-number">149.</span> def getBlankPosition(board):</p>
		<p class="noindent mono"><span class="line-number">150.</span> &#160;&#160;&#160;&#160;<span class="comment"># Return the x and y of board coordinates of the blank space.</span></p>
		<p class="noindent mono"><span class="line-number">151.</span> &#160;&#160;&#160;&#160;for x in range(BOARDWIDTH):</p>
		<p class="noindent mono"><span class="line-number">152.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for y in range(BOARDHEIGHT):</p>
		<p class="noindent mono"><span class="line-number">153.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if board[x][y] == None:</p>
		<p class="noindent mono"><span class="line-number">154.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return (x, y)</p>
		<p class="noindent mono"><span class="line-number">155.</span></p>
		<p class="noindent mono"><span class="line-number">156.</span></p>
		<p class="noindent mono"><span class="line-number">157.</span> def makeMove(board, move):</p>
		<p class="noindent mono"><span class="line-number">158.</span> &#160;&#160;&#160;&#160;<span class="comment"># This function does not check if the move is valid.</span></p>
		<p class="noindent mono"><span class="line-number">159.</span> &#160;&#160;&#160;&#160;blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">160.</span></p>
		<p class="noindent mono"><span class="line-number">161.</span> &#160;&#160;&#160;&#160;if move == UP:</p>
		<p class="noindent mono"><span class="line-number">162.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board[blankx][blanky], board[blankx][blanky + 1] = board[blankx][blanky + 1], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">163.</span> &#160;&#160;&#160;&#160;elif move == DOWN:</p>
		<p class="noindent mono"><span class="line-number">164.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board[blankx][blanky], board[blankx][blanky - 1] = board[blankx][blanky - 1], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">165.</span> &#160;&#160;&#160;&#160;elif move == LEFT:</p>
		<p class="noindent mono"><span class="line-number">166.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + 1][blanky], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">167.</span> &#160;&#160;&#160;&#160;elif move == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">168.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - 1][blanky], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">169.</span></p>
		<p class="noindent mono"><span class="line-number">170.</span></p>
		<p class="noindent mono"><span class="line-number">171.</span> def isValidMove(board, move):</p>
		<p class="noindent mono"><span class="line-number">172.</span> &#160;&#160;&#160;&#160;blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">173.</span> &#160;&#160;&#160;&#160;return (move == UP and blanky != len(board[0]) - 1) or \</p>
		<p class="noindent mono"><span class="line-number">174.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(move == DOWN and blanky != 0) or \</p>
		<p class="noindent mono"><span class="line-number">175.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(move == LEFT and blankx != len(board) - 1) or \</p>
		<p class="noindent mono"><span class="line-number">176.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(move == RIGHT and blankx != 0)</p>
		<p class="noindent mono"><span class="line-number">177.</span></p>
		<p class="noindent mono"><span class="line-number">178.</span></p>
		<p class="noindent mono"><span class="line-number">179.</span> def getRandomMove(board, lastMove=None):</p>
		<p class="noindent mono"><span class="line-number">180.</span> &#160;&#160;&#160;&#160;<span class="comment"># start with a full list of all four moves</span></p>
		<p class="noindent mono"><span class="line-number">181.</span> &#160;&#160;&#160;&#160;validMoves = [UP, DOWN, LEFT, RIGHT]</p>
		<p class="noindent mono"><span class="line-number">182.</span></p>
		<p class="noindent mono"><span class="line-number">183.</span> &#160;&#160;&#160;&#160;<span class="comment"># remove moves from the list as they are disqualified</span></p>
		<p class="noindent mono"><span class="line-number">184.</span> &#160;&#160;&#160;&#160;if lastMove == UP or not isValidMove(board, DOWN):</p>
		<p class="noindent mono"><span class="line-number">185.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;validMoves.remove(DOWN)</p>
		<p class="noindent mono"><span class="line-number">186.</span> &#160;&#160;&#160;&#160;if lastMove == DOWN or not isValidMove(board, UP):</p>
		<p class="noindent mono"><span class="line-number">187.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;validMoves.remove(UP)</p>
		<p class="noindent mono"><span class="line-number">188.</span> &#160;&#160;&#160;&#160;if lastMove == LEFT or not isValidMove(board, RIGHT):</p>
		<p class="noindent mono"><span class="line-number">189.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;validMoves.remove(RIGHT)</p>
		<p class="noindent mono"><span class="line-number">190.</span> &#160;&#160;&#160;&#160;if lastMove == RIGHT or not isValidMove(board, LEFT):</p>
		<p class="noindent mono"><span class="line-number">191.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;validMoves.remove(LEFT)</p>
		<p class="noindent mono"><span class="line-number">192.</span></p>
		<p class="noindent mono"><span class="line-number">193.</span> &#160;&#160;&#160;&#160;<span class="comment"># return a random move from the list of remaining moves</span></p>
		<p class="noindent mono"><span class="line-number">194.</span> &#160;&#160;&#160;&#160;return random.choice(validMoves)</p>
		<p class="noindent mono"><span class="line-number">195.</span></p>
		<p class="noindent mono"><span class="line-number">196.</span></p>
		<p class="noindent mono"><span class="line-number">197.</span> def getLeftTopOfTile(tileX, tileY):</p>
		<p class="noindent mono"><span class="line-number">198.</span> &#160;&#160;&#160;&#160;left = XMARGIN + (tileX * TILESIZE) + (tileX - 1)</p>
		<p class="noindent mono"><span class="line-number">199.</span> &#160;&#160;&#160;&#160;top = YMARGIN + (tileY * TILESIZE) + (tileY - 1)</p>
		<p class="noindent mono"><span class="line-number">200.</span> &#160;&#160;&#160;&#160;return (left, top)</p>
		<p class="noindent mono"><span class="line-number">201.</span></p>
		<p class="noindent mono"><span class="line-number">202.</span></p>
		<p class="noindent mono"><span class="line-number">203.</span> def getSpotClicked(board, x, y):</p>
		<p class="noindent mono"><span class="line-number">204.</span> &#160;&#160;&#160;&#160;<span class="comment"># from the x &amp; y pixel coordinates, get the x &amp; y board coordinates</span></p>
		<p class="noindent mono"><span class="line-number">205.</span> &#160;&#160;&#160;&#160;for tileX in range(len(board)):</p>
		<p class="noindent mono"><span class="line-number">206.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for tileY in range(len(board[0])):</p>
		<p class="noindent mono"><span class="line-number">207.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left, top = getLeftTopOfTile(tileX, tileY)</p>
		<p class="noindent mono"><span class="line-number">208.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE)</p>
		<p class="noindent mono"><span class="line-number">209.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if tileRect.collidepoint(x, y):</p>
		<p class="noindent mono"><span class="line-number">210.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return (tileX, tileY)</p>
		<p class="noindent mono"><span class="line-number">211.</span> &#160;&#160;&#160;&#160;return (None, None)</p>
		<p class="noindent mono"><span class="line-number">212.</span></p>
		<p class="noindent mono"><span class="line-number">213.</span></p>
		<p class="noindent mono"><span class="line-number">214.</span> def drawTile(tilex, tiley, number, adjx=0, adjy=0):</p>
		<p class="noindent mono"><span class="line-number">215.</span> &#160;&#160;&#160;&#160;<span class="comment"># draw a tile at board coordinates tilex and tiley, optionally a few</span></p>
		<p class="noindent mono"><span class="line-number">216.</span> &#160;&#160;&#160;&#160;<span class="comment"># pixels over (determined by adjx and adjy)</span></p>
		<p class="noindent mono"><span class="line-number">217.</span> &#160;&#160;&#160;&#160;left, top = getLeftTopOfTile(tilex, tiley)</p>
		<p class="noindent mono"><span class="line-number">218.</span> &#160;&#160;&#160;&#160;pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, TILESIZE, TILESIZE))</p>
		<p class="noindent mono"><span class="line-number">219.</span> &#160;&#160;&#160;&#160;textSurf = BASICFONT.render(str(number), True, TEXTCOLOR)</p>
		<p class="noindent mono"><span class="line-number">220.</span> &#160;&#160;&#160;&#160;textRect = textSurf.get_rect()</p>
		<p class="noindent mono"><span class="line-number">221.</span> &#160;&#160;&#160;&#160;textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE / 2) + adjy</p>
		<p class="noindent mono"><span class="line-number">222.</span> &#160;&#160;&#160;&#160;DISPLAYSURF.blit(textSurf, textRect)</p>
		<p class="noindent mono"><span class="line-number">223.</span></p>
		<p class="noindent mono"><span class="line-number">224.</span></p>
		<p class="noindent mono"><span class="line-number">225.</span> def makeText(text, color, bgcolor, top, left):</p>
		<p class="noindent mono"><span class="line-number">226.</span> &#160;&#160;&#160;&#160;<span class="comment"># create the Surface and Rect objects for some text.</span></p>
		<p class="noindent mono"><span class="line-number">227.</span> &#160;&#160;&#160;&#160;textSurf = BASICFONT.render(text, True, color, bgcolor)</p>
		<p class="noindent mono"><span class="line-number">228.</span> &#160;&#160;&#160;&#160;textRect = textSurf.get_rect()</p>
		<p class="noindent mono"><span class="line-number">229.</span> &#160;&#160;&#160;&#160;textRect.topleft = (top, left)</p>
		<p class="noindent mono"><span class="line-number">230.</span> &#160;&#160;&#160;&#160;return (textSurf, textRect)</p>
		<p class="noindent mono"><span class="line-number">231.</span></p>
		<p class="noindent mono"><span class="line-number">232.</span></p>
		<p class="noindent mono"><span class="line-number">233.</span> def drawBoard(board, message):</p>
		<p class="noindent mono"><span class="line-number">234.</span> &#160;&#160;&#160;&#160;DISPLAYSURF.fill(BGCOLOR)</p>
		<p class="noindent mono"><span class="line-number">235.</span> &#160;&#160;&#160;&#160;if message:</p>
		<p class="noindent mono"><span class="line-number">236.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;textSurf, textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, 5)</p>
		<p class="noindent mono"><span class="line-number">237.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DISPLAYSURF.blit(textSurf, textRect)</p>
		<p class="noindent mono"><span class="line-number">238.</span></p>
		<p class="noindent mono"><span class="line-number">239.</span> &#160;&#160;&#160;&#160;for tilex in range(len(board)):</p>
		<p class="noindent mono"><span class="line-number">240.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for tiley in range(len(board[0])):</p>
		<p class="noindent mono"><span class="line-number">241.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if board[tilex][tiley]:</p>
		<p class="noindent mono"><span class="line-number">242.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(tilex, tiley, board[tilex][tiley])</p>
		<p class="noindent mono"><span class="line-number">243.</span></p>
		<p class="noindent mono"><span class="line-number">244.</span> &#160;&#160;&#160;&#160;left, top = getLeftTopOfTile(0, 0)</p>
		<p class="noindent mono"><span class="line-number">245.</span> &#160;&#160;&#160;&#160;width = BOARDWIDTH * TILESIZE</p>
		<p class="noindent mono"><span class="line-number">246.</span> &#160;&#160;&#160;&#160;height = BOARDHEIGHT * TILESIZE</p>
		<p class="noindent mono"><span class="line-number">247.</span> &#160;&#160;&#160;&#160;pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + 11, height + 11), 4)</p>
		<p class="noindent mono"><span class="line-number">248.</span></p>
		<p class="noindent mono"><span class="line-number">249.</span> &#160;&#160;&#160;&#160;DISPLAYSURF.blit(RESET_SURF, RESET_RECT)</p>
		<p class="noindent mono"><span class="line-number">250.</span> &#160;&#160;&#160;&#160;DISPLAYSURF.blit(NEW_SURF, NEW_RECT)</p>
		<p class="noindent mono"><span class="line-number">251.</span> &#160;&#160;&#160;&#160;DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT)</p>
		<p class="noindent mono"><span class="line-number">252.</span></p>
		<p class="noindent mono"><span class="line-number">253.</span></p>
		<p class="noindent mono"><span class="line-number">254.</span> def slideAnimation(board, direction, message, animationSpeed):</p>
		<p class="noindent mono"><span class="line-number">255.</span> &#160;&#160;&#160;&#160;<span class="comment"># Note: This function does not check if the move is valid.</span></p>
		<p class="noindent mono"><span class="line-number">256.</span></p>
		<p class="noindent mono"><span class="line-number">257.</span> &#160;&#160;&#160;&#160;blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">258.</span> &#160;&#160;&#160;&#160;if direction == UP:</p>
		<p class="noindent mono"><span class="line-number">259.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx</p>
		<p class="noindent mono"><span class="line-number">260.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky + 1</p>
		<p class="noindent mono"><span class="line-number">261.</span> &#160;&#160;&#160;&#160;elif direction == DOWN:</p>
		<p class="noindent mono"><span class="line-number">262.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx</p>
		<p class="noindent mono"><span class="line-number">263.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky - 1</p>
		<p class="noindent mono"><span class="line-number">264.</span> &#160;&#160;&#160;&#160;elif direction == LEFT:</p>
		<p class="noindent mono"><span class="line-number">265.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx + 1</p>
		<p class="noindent mono"><span class="line-number">266.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky</p>
		<p class="noindent mono"><span class="line-number">267.</span> &#160;&#160;&#160;&#160;elif direction == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">268.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx - 1</p>
		<p class="noindent mono"><span class="line-number">269.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky</p>
		<p class="noindent mono"><span class="line-number">270.</span></p>
		<p class="noindent mono"><span class="line-number">271.</span> &#160;&#160;&#160;&#160;<span class="comment"># prepare the base surface</span></p>
		<p class="noindent mono"><span class="line-number">272.</span> &#160;&#160;&#160;&#160;drawBoard(board, message)</p>
		<p class="noindent mono"><span class="line-number">273.</span> &#160;&#160;&#160;&#160;baseSurf = DISPLAYSURF.copy()</p>
		<p class="noindent mono"><span class="line-number">274.</span> &#160;&#160;&#160;&#160;<span class="comment"># draw a blank space over the moving tile on the baseSurf Surface.</span></p>
		<p class="noindent mono"><span class="line-number">275.</span> &#160;&#160;&#160;&#160;moveLeft, moveTop = getLeftTopOfTile(movex, movey)</p>
		<p class="noindent mono"><span class="line-number">276.</span> &#160;&#160;&#160;&#160;pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))</p>
		<p class="noindent mono"><span class="line-number">277.</span></p>
		<p class="noindent mono"><span class="line-number">278.</span> &#160;&#160;&#160;&#160;for i in range(0, TILESIZE, animationSpeed):</p>
		<p class="noindent mono"><span class="line-number">279.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># animate the tile sliding over</span></p>
		<p class="noindent mono"><span class="line-number">280.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;checkForQuit()</p>
		<p class="noindent mono"><span class="line-number">281.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DISPLAYSURF.blit(baseSurf, (0, 0))</p>
		<p class="noindent mono"><span class="line-number">282.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == UP:</p>
		<p class="noindent mono"><span class="line-number">283.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], 0, -i)</p>
		<p class="noindent mono"><span class="line-number">284.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == DOWN:</p>
		<p class="noindent mono"><span class="line-number">285.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], 0, i)</p>
		<p class="noindent mono"><span class="line-number">286.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == LEFT:</p>
		<p class="noindent mono"><span class="line-number">287.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], -i, 0)</p>
		<p class="noindent mono"><span class="line-number">288.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">289.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], i, 0)</p>
		<p class="noindent mono"><span class="line-number">290.</span></p>
		<p class="noindent mono"><span class="line-number">291.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">292.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FPSCLOCK.tick(FPS)</p>
		<p class="noindent mono"><span class="line-number">293.</span></p>
		<p class="noindent mono"><span class="line-number">294.</span></p>
		<p class="noindent mono"><span class="line-number">295.</span> def generateNewPuzzle(numSlides):</p>
		<p class="noindent mono"><span class="line-number">296.</span> &#160;&#160;&#160;&#160;<span class="comment"># From a starting configuration, make numSlides number of moves (and</span></p>
		<p class="noindent mono"><span class="line-number">297.</span> &#160;&#160;&#160;&#160;<span class="comment"># animate these moves).</span></p>
		<p class="noindent mono"><span class="line-number">298.</span> &#160;&#160;&#160;&#160;sequence = []</p>
		<p class="noindent mono"><span class="line-number">299.</span> &#160;&#160;&#160;&#160;board = getStartingBoard()</p>
		<p class="noindent mono"><span class="line-number">300.</span> &#160;&#160;&#160;&#160;drawBoard(board, '')</p>
		<p class="noindent mono"><span class="line-number">301.</span> &#160;&#160;&#160;&#160;pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">302.</span> &#160;&#160;&#160;&#160;pygame.time.wait(500) <span class="comment"># pause 500 milliseconds for effect</span></p>
		<p class="noindent mono"><span class="line-number">303.</span> &#160;&#160;&#160;&#160;lastMove = None</p>
		<p class="noindent mono"><span class="line-number">304.</span> &#160;&#160;&#160;&#160;for i in range(numSlides):</p>
		<p class="noindent mono"><span class="line-number">305.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;move = getRandomMove(board, lastMove)</p>
		<p class="noindent mono"><span class="line-number">306.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideAnimation(board, move, 'Generating new puzzle...', int(TILESIZE / 3))</p>
		<p class="noindent mono"><span class="line-number">307.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;makeMove(board, move)</p>
		<p class="noindent mono"><span class="line-number">308.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sequence.append(move)</p>
		<p class="noindent mono"><span class="line-number">309.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastMove = move</p>
		<p class="noindent mono"><span class="line-number">310.</span> &#160;&#160;&#160;&#160;return (board, sequence)</p>
		<p class="noindent mono"><span class="line-number">311.</span></p>
		<p class="noindent mono"><span class="line-number">312.</span></p>
		<p class="noindent mono"><span class="line-number">313.</span> def resetAnimation(board, allMoves):</p>
		<p class="noindent mono"><span class="line-number">314.</span> &#160;&#160;&#160;&#160;<span class="comment"># make all of the moves in allMoves in reverse.</span></p>
		<p class="noindent mono"><span class="line-number">315.</span> &#160;&#160;&#160;&#160;revAllMoves = allMoves[:] <span class="comment"># gets a copy of the list</span></p>
		<p class="noindent mono"><span class="line-number">316.</span> &#160;&#160;&#160;&#160;revAllMoves.reverse()</p>
		<p class="noindent mono"><span class="line-number">317.</span></p>
		<p class="noindent mono"><span class="line-number">318.</span> &#160;&#160;&#160;&#160;for move in revAllMoves:</p>
		<p class="noindent mono"><span class="line-number">319.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if move == UP:</p>
		<p class="noindent mono"><span class="line-number">320.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = DOWN</p>
		<p class="noindent mono"><span class="line-number">321.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == DOWN:</p>
		<p class="noindent mono"><span class="line-number">322.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = UP</p>
		<p class="noindent mono"><span class="line-number">323.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">324.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = LEFT</p>
		<p class="noindent mono"><span class="line-number">325.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == LEFT:</p>
		<p class="noindent mono"><span class="line-number">326.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = RIGHT</p>
		<p class="noindent mono"><span class="line-number">327.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideAnimation(board, oppositeMove, '', int(TILESIZE / 2))</p>
		<p class="noindent mono"><span class="line-number">328.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;makeMove(board, oppositeMove)</p>
		<p class="noindent mono"><span class="line-number">329.</span></p>
		<p class="noindent mono"><span class="line-number">330.</span></p>
		<p class="noindent mono"><span class="line-number">331.</span> if __name__ == '__main__':</p>
		<p class="noindent mono"><span class="line-number">332.</span> &#160;&#160;&#160;&#160;main()</p>
	</div>

	<h1 class="subheading" id="second-verse">Second Verse, Same as the First</h1>
	<p class="noindent">Much of the code in Wormy is similar to the previous games we’ve looked at, especially the constants being set at the start of the code.</p>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;&#160;1.</span> <span class="comment"># Slide Puzzle</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;2.</span> <span class="comment"># By Al Sweigart al@inventwithpython.com</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;3.</span> <span class="comment"># http://inventwithpython.com/pygame</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;4.</span> <span class="comment"># Creative Commons BY-NC-SA 3.0 US</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;5.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;6.</span> import pygame, sys, random</p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;7.</span> from pygame.locals import *</p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;8.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;&#160;9.</span> <span class="comment"># Create the constants (go ahead and experiment with different values)</span></p>
		<p class="noindent mono"><span class="line-number">&#160;10.</span> BOARDWIDTH = 4  <span class="comment"># number of columns in the board</span></p>
		<p class="noindent mono"><span class="line-number">&#160;11.</span> BOARDHEIGHT = 4 <span class="comment"># number of rows in the board</span></p>
		<p class="noindent mono"><span class="line-number">&#160;12.</span> TILESIZE = 80</p>
		<p class="noindent mono"><span class="line-number">&#160;13.</span> WINDOWWIDTH = 640</p>
		<p class="noindent mono"><span class="line-number">&#160;14.</span> WINDOWHEIGHT = 480</p>
		<p class="noindent mono"><span class="line-number">&#160;15.</span> FPS = 30</p>
		<p class="noindent mono"><span class="line-number">&#160;16.</span> BLANK = None</p>
		<p class="noindent mono"><span class="line-number">&#160;17.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;18.</span> <span class="comment"># &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;R&#160;&#160;&#160;&#160;G&#160;&#160;&#160;&#160;B</span></p>
		<p class="noindent mono"><span class="line-number">&#160;19.</span> BLACK = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#160;&#160;0, &#160;&#160;0, &#160;&#160;0)</p>
		<p class="noindent mono"><span class="line-number">&#160;20.</span> WHITE = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(255, 255, 255)</p>
		<p class="noindent mono"><span class="line-number">&#160;21.</span> BRIGHTBLUE = &#160;&#160;&#160;(&#160;&#160;0, &#160;50, 255)</p>
		<p class="noindent mono"><span class="line-number">&#160;22.</span> DARKTURQUOISE = (&#160;&#160;3, &#160;54, &#160;73)</p>
		<p class="noindent mono"><span class="line-number">&#160;23.</span> GREEN = &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#160;&#160;0, 204, &#160;&#160;0)</p>
		<p class="noindent mono"><span class="line-number">&#160;24.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;25.</span> BGCOLOR = DARKTURQUOISE</p>
		<p class="noindent mono"><span class="line-number">&#160;26.</span> TILECOLOR = GREEN</p>
		<p class="noindent mono"><span class="line-number">&#160;27.</span> TEXTCOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;28.</span> BORDERCOLOR = BRIGHTBLUE</p>
		<p class="noindent mono"><span class="line-number">&#160;29.</span> BASICFONTSIZE = 20</p>
		<p class="noindent mono"><span class="line-number">&#160;30.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;31.</span> BUTTONCOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;32.</span> BUTTONTEXTCOLOR = BLACK</p>
		<p class="noindent mono"><span class="line-number">&#160;33.</span> MESSAGECOLOR = WHITE</p>
		<p class="noindent mono"><span class="line-number">&#160;34.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;35.</span> XMARGIN = int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / 2)</p>
		<p class="noindent mono"><span class="line-number">&#160;36.</span> YMARGIN = int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - 1))) / 2)</p>
		<p class="noindent mono"><span class="line-number">&#160;37.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;38.</span> UP = 'up'</p>
		<p class="noindent mono"><span class="line-number">&#160;39.</span> DOWN = 'down'</p>
		<p class="noindent mono"><span class="line-number">&#160;40.</span> LEFT = 'left'</p>
		<p class="noindent mono"><span class="line-number">&#160;41.</span> RIGHT = 'right'</p>
	</div>

	<p>This code at the top of the program just handles all the basic importing of modules and creating constants. This is just like the beginning of the Memory Puzzle game from the last chapter.</p>

	<h1 class="subheading" id="setting-up-buttons">Setting Up the Buttons</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;43.</span> def main():</p>
		<p class="noindent mono"><span class="line-number">&#160;44.</span> &#160;&#160;&#160;&#160;global FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, NEW_SURF, NEW_RECT, SOLVE_SURF, SOLVE_RECT</p>
		<p class="noindent mono"><span class="line-number">&#160;45.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;46.</span> &#160;&#160;&#160;&#160;pygame.init()</p>
		<p class="noindent mono"><span class="line-number">&#160;47.</span> &#160;&#160;&#160;&#160;FPSCLOCK = pygame.time.Clock()</p>
		<p class="noindent mono"><span class="line-number">&#160;48.</span> &#160;&#160;&#160;&#160;DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))</p>
		<p class="noindent mono"><span class="line-number">&#160;49.</span> &#160;&#160;&#160;&#160;pygame.display.set_caption('Slide Puzzle')</p>
		<p class="noindent mono"><span class="line-number">&#160;50.</span> &#160;&#160;&#160;&#160;BASICFONT = pygame.font.Font('freesansbold.ttf', BASICFONTSIZE)</p>
		<p class="noindent mono"><span class="line-number">&#160;51.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;52.</span> &#160;&#160;&#160;&#160;<span class="comment"># Store the option buttons and their rectangles in OPTIONS.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;53.</span> &#160;&#160;&#160;&#160;RESET_SURF, RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 90)</p>
		<p class="noindent mono"><span class="line-number">&#160;54.</span> &#160;&#160;&#160;&#160;NEW_SURF, NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 60)</p>
		<p class="noindent mono"><span class="line-number">&#160;55.</span> &#160;&#160;&#160;&#160;SOLVE_SURF, SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120, WINDOWHEIGHT - 30)</p>
		<p class="noindent mono"><span class="line-number">&#160;56.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;57.</span> &#160;&#160;&#160;&#160;mainBoard, solutionSeq = generateNewPuzzle(80)</p>
		<p class="noindent mono"><span class="line-number">&#160;58.</span> &#160;&#160;&#160;&#160;SOLVEDBOARD = getStartingBoard() <span class="comment"># a solved board is the same as the board in a start state.</span></p>
	</div>

	<p>Just like in the last chapter, the functions called from the <span class="mono">main()</span> function calls will be explained later in the chapter. For now, you just need to know what they do and what values they return. You don’t need to know how they work.</p>
	<p>The first part of the <span class="mono">main()</span> function will handle creating the window, Clock object, and Font object. The <span class="mono">makeText()</span> function is defined later in the program, but for now you just need to know that it returns a <span class="mono">pygame.Surface</span> object and <span class="mono">pygame.Rect</span> object which can be used to make clickable buttons. The Slide Puzzle game will have three buttons: a “Reset” button that will undo any moves the player has made, a “New” button that will create a new slide puzzle, and a “Solve” button that will solve the puzzle for the player.</p>
	<p>We will need to have two board data structures for this program. One board will represent the current game state. The other board will have its tiles in the “solved” state, meaning that all the tiles are lined up in order. When the current game state’s board is exactly the same as the solved board, then we know the player has won. (We won’t ever change this second one. It’ll just be there to compare the current game state board to.)</p>
	<p>The <span class="mono">generateNewPuzzle()</span> will create a board data structure that started off in the ordered, solved state and then had 80 random slide moves performed on it (because we passed the integer <span class="mono">80</span> to it. If we want the board to be even more jumbled, then we can pass a larger integer to it). This will make the board into a randomly jumbled state that the player will have to solve (which will be stored in a variable named <span class="mono">mainBoard</span>). The <span class="mono">generateNewBoard()</span> also returns a list of all the random moves that were performed on it (which will be stored in a variable named <span class="mono">solutionSeq</span>).</p>

	<h1 class="subheading" id="stupid-code">Being Smart By Using Stupid Code</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;59.</span> &#160;&#160;&#160;&#160;allMoves = [] <span class="comment"># list of moves made from the solved configuration</span></p>
	</div>

	<p>Solving a slide puzzle can be really tricky. We could program the computer to do it, but that would require us to figure out an algorithm that can solve the slide puzzle. That would be very difficult and involve a lot of cleverness and effort to put into this program. </p>
	<p>Fortunately, there’s an easier way. We could just have the computer memorize all the random slides it made when it created the board data structure, and then the board can be solved just by performing the opposite slide. Since the board originally started in the solved state, undoing all the slides would return it to the solved state.</p>
	<p>For example, below we perform a “right” slide on the board on the left side of the page, which leaves the board in the state that is on the right side of the page:</p>

	<div class="image-center">
		<img class="half-image" src="images/chapter4/sliding.jpg" alt=""/>
	</div>

	<p>After the right slide, if we do the opposite slide (a left slide) then the board will be back in the original state. So to get back to the original state after several slides, we just have to do the opposite slides in reverse order. If we did a right slide, then another right slide, then a down slide, we would have to do an up slide, left slide, and left slide to undo those first three slides. This is much easier than writing a function that can solve these puzzles simply by looking at the current state of them.</p>

	<h1 class="subheading" id="main-loop">The Main Game Loop</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;61.</span> &#160;&#160;&#160;&#160;while True: <span class="comment"># main game loop</span></p>
		<p class="noindent mono"><span class="line-number">&#160;62.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideTo = None <span class="comment"># the direction, if any, a tile should slide</span></p>
		<p class="noindent mono"><span class="line-number">&#160;63.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg = '' <span class="comment"># contains the message to show in the upper left corner.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;64.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if mainBoard == SOLVEDBOARD:</p>
		<p class="noindent mono"><span class="line-number">&#160;65.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;msg = 'Solved!'</p>
		<p class="noindent mono"><span class="line-number">&#160;66.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;67.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawBoard(mainBoard, msg)</p>
	</div>

	<p>In the main game loop, the <span class="mono">slideTo</span> variable will track which direction the player wants to slide a tile (it starts off at the beginning of the game loop as <span class="mono">None</span> and is set later) and the <span class="mono">msg</span> variable tracks what string to display at the top of the window. The program does a quick check on line 64 to see if the board data structure has the same value as the solved board data structure stored in <span class="mono">SOLVEDBOARD</span>. If so, then the <span class="mono">msg</span> variable is changed to the string <span class="mono">'Solved!'</span>. This won’t appear on the screen until <span class="mono">drawBoard()</span> has been called to draw it to the <span class="mono">DISPLAYSURF</span> Surface object (which is done on line 67) and <span class="mono">pygame.display.update()</span> is called to draw the display Surface object on the actual computer screen (which is done on line 291 at the end of the game loop).</p>

	<h1 class="subheading" id="clicking-buttons">Clicking on the Buttons</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;69.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;checkForQuit()</p>
		<p class="noindent mono"><span class="line-number">&#160;70.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for event in pygame.event.get(): <span class="comment"># event handling loop</span></p>
		<p class="noindent mono"><span class="line-number">&#160;71.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if event.type == MOUSEBUTTONUP:</p>
		<p class="noindent mono"><span class="line-number">&#160;72.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;spotx, spoty = getSpotClicked(mainBoard, event.pos[0], event.pos[1])</p>
		<p class="noindent mono"><span class="line-number">&#160;73.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;74.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (spotx, spoty) == (None, None):</p>
		<p class="noindent mono"><span class="line-number">&#160;75.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># check if the user clicked on an option button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;76.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if RESET_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;77.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resetAnimation(mainBoard, allMoves) <span class="comment"># clicked on Reset button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;78.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
		<p class="noindent mono"><span class="line-number">&#160;79.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif NEW_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;80.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mainBoard, solutionSeq = generateNewPuzzle(80) <span class="comment"># clicked on New Game button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;81.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
		<p class="noindent mono"><span class="line-number">&#160;82.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif SOLVE_RECT.collidepoint(event.pos):</p>
		<p class="noindent mono"><span class="line-number">&#160;83.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;resetAnimation(mainBoard, solutionSeq + allMoves) <span class="comment"># clicked on Solve button</span></p>
		<p class="noindent mono"><span class="line-number">&#160;84.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;allMoves = []</p>
	</div>

	<p>Before going into the event loop, the program calls <span class="mono">checkForQuit()</span> on line 69 to see if any <span class="mono">QUIT</span> events have been created (and terminates the program if there have). Why we have a separate function (the <span class="mono">checkForQuit()</span> function) for handling the <span class="mono">QUIT</span> events will be explained later. The <span class="mono">for</span> loop on line 70 executes the event handling code for any other event created since the last time <span class="mono">pygame.event.get()</span> was called (or since the program started, if <span class="mono">pygame.event.get()</span> has never been called before).</p>
	<p>If the type of event was a <span class="mono">MOUSEBUTTONUP</span> event (that is, the player had released a mouse button somewhere over the window), then we pass the mouse coordinates to our <span class="mono">getSpotClicked()</span> function which will return the board coordinates of the spot on the board the mouse release happened. The <span class="mono">event.pos[0]</span> is the X coordinate and <span class="mono">event.pos[1]</span> is the Y coordinate.</p>
	<p>If the mouse button release did not happen over one of the spaces on the board (but obviously still happened somewhere on the window, since a <span class="mono">MOUSEBUTTONUP</span> event was created), then <span class="mono">getSpotClicked()</span> will return <span class="mono">None</span>. If this is the case, we want to do an additional check to see if the player might have clicked on the Reset, New, or Solve buttons (which are not located on the board). </p>
	<p>The coordinates of where these buttons are on the window are stored in the <span class="mono">pygame.Rect</span> objects that are stored in the <span class="mono">RESET_RECT</span>, <span class="mono">NEW_RECT</span>, and <span class="mono">SOLVE_RECT</span> variables. We can pass the mouse coordinates from the Event object to the <span class="mono">collidepoint()</span> method. This method will return <span class="mono">True</span> if the mouse coordinates are within the Rect object’s area and <span class="mono">False</span> otherwise.</p>

	<h1 class="subheading" id="sliding-tiles-mouse">Sliding Tiles with the Mouse</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;85.</span>                 else:</p>
		<p class="noindent mono"><span class="line-number">&#160;86.</span>                     <span class="comment"># check if the clicked tile was next to the blank spot</span></p>
		<p class="noindent mono"><span class="line-number">&#160;87.</span></p>
		<p class="noindent mono"><span class="line-number">&#160;88.</span>                     blankx, blanky = getBlankPosition(mainBoard)</p>
		<p class="noindent mono"><span class="line-number">&#160;89.</span>                     if spotx == blankx + 1 and spoty == blanky:</p>
		<p class="noindent mono"><span class="line-number">&#160;90.</span>                         slideTo = LEFT</p>
		<p class="noindent mono"><span class="line-number">&#160;91.</span>                     elif spotx == blankx - 1 and spoty == blanky:</p>
		<p class="noindent mono"><span class="line-number">&#160;92.</span>                         slideTo = RIGHT</p>
		<p class="noindent mono"><span class="line-number">&#160;93.</span>                     elif spotx == blankx and spoty == blanky + 1:</p>
		<p class="noindent mono"><span class="line-number">&#160;94.</span>                         slideTo = UP</p>
		<p class="noindent mono"><span class="line-number">&#160;95.</span>                     elif spotx == blankx and spoty == blanky - 1:</p>
		<p class="noindent mono"><span class="line-number">&#160;96.</span>                         slideTo = DOWN</p>
	</div>

	<p>If <span class="mono">getSpotClicked()</span> did not return <span class="mono">(None, None)</span>, then it will have returned a tuple of two integer values that represent the X and Y coordinate of the spot on the board that was clicked. Then the <span class="mono">if</span> and <span class="mono">elif</span> statements on lines 89 to 96 check if the spot that was clicked is a tile that is next to the blank spot (otherwise the tile will have no place to slide).</p>
	<p>Our <span class="mono">getBlankPosition()</span> function will take the board data structure and return the X and Y board coordinates of the blank spot, which we store in the variables <span class="mono">blankx</span> and <span class="mono">blanky</span>. If the spot the user clicked on was next to the blank space, we set the <span class="mono">slideTo</span> variable with the value that the tile should slide.</p>

	<h1 class="subheading" id="sliding-tiles-keyboard">Sliding Tiles with the Keyboard</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">&#160;98.</span>             elif event.type == KEYUP:</p>
		<p class="noindent mono"><span class="line-number">&#160;99.</span>                 <span class="comment"># check if the user pressed a key to slide a tile</span></p>
		<p class="noindent mono"><span class="line-number">100.</span>                 if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):</p>
		<p class="noindent mono"><span class="line-number">101.</span>                     slideTo = LEFT</p>
		<p class="noindent mono"><span class="line-number">102.</span>                 elif event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):</p>
		<p class="noindent mono"><span class="line-number">103.</span>                     slideTo = RIGHT</p>
		<p class="noindent mono"><span class="line-number">104.</span>                 elif event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):</p>
		<p class="noindent mono"><span class="line-number">105.</span>                     slideTo = UP</p>
		<p class="noindent mono"><span class="line-number">106.</span>                 elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):</p>
		<p class="noindent mono"><span class="line-number">107.</span>                     slideTo = DOWN</p>
	</div>

	<p>We can also let the user slide tiles by pressing keyboard keys. The <span class="mono">if</span> and <span class="mono">elif</span> statements on lines 100 to 107 let the user set the <span class="mono">slideTo</span> variable by either pressing the arrow keys or the WASD keys (explained later). Each <span class="mono">if</span> and <span class="mono">elif</span> statement also has a call to <span class="mono">isValidMove()</span> to make sure that the tile can slide in that direction. (We didn’t have to make this call with the mouse clicks because the checks for the neighboring blank space did the same thing.)</p>

	<h1 class="subheading" id="equal-to-one">“Equal To One Of” Trick with the <span class="mono">in</span> Operator</h1>
	<p class="noindent">The expression <span class="mono">event.key in (K_LEFT, K_a)</span> is just a Python trick to make the code simpler. It is a way of saying “evaluate to <span class="mono">True</span> if <span class="mono">event.key</span> is equal to one of <span class="mono">K_LEFT</span> or <span class="mono">K_a</span>”. The following two expressions will evaluate the exact same way:</p>

	<div class="python-shell">
		<p class="noindent mono">event.key in (K_LEFT, K_a)</p>
		<p class="noindent mono"></p>
		<p class="noindent mono">event.key == K_LEFT or event.key == K_a</p>
	</div>

	<p>You can really save on some space by using this trick when you have to check if a value is equal to one of multiple values. The following two expressions will evaluate the exact same way:</p>

	<div class="python-shell">
		<p class="noindent mono">spam == 'dog' or spam == 'cat' or spam == 'mouse' or spam == 'horse' or spam == 42 or spam == 'dingo'</p>
		<p class="noindent mono"></p>
		<p class="noindent mono">spam in ('dog', 'cat', 'mouse', 'horse', 42, 'dingo')</p>
	</div>

	<h1 class="subheading" id="wasd-arrow-keys">WASD and Arrow Keys</h1>
	<p class="noindent">The W, A, S, and D keys (together called the WASD keys, pronounced “waz-dee”) are commonly used in computer games to do the same thing as the arrow keys, except the player can use their left hand instead (since the WASD keys are on the left side of the keyboard). W is for up, A is for left, S is for down, and D is for right. You can easily remember this because the WASD keys have the same layout as the arrow keys:</p>

	<div class="image-center">
		<img class="half-image" src="images/chapter4/wasd-arrows.jpg" alt=""/>
	</div>

	<h1 class="subheading" id="performing-tile-slide">Actually Performing the Tile Slide</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">109.</span>         if slideTo:</p>
		<p class="noindent mono"><span class="line-number">110.</span>             slideAnimation(mainBoard, slideTo, 'Click tile or press arrow keys to slide.', 8) <span class="comment"># show slide on screen</span></p>
		<p class="noindent mono"><span class="line-number">111.</span>             makeMove(mainBoard, slideTo)</p>
		<p class="noindent mono"><span class="line-number">112.</span>             allMoves.append(slideTo) <span class="comment"># record the slide</span></p>
		<p class="noindent mono"><span class="line-number">113.</span>         pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">114.</span>         FPSCLOCK.tick(FPS)</p>
	</div>

	<p>Now that the events have all been handled, we should update the variables of the game state and display the new state on the screen. If <span class="mono">slideTo</span> has been set (either by the mouse event or keyboard event handling code) then we can call <span class="mono">slideAnimation()</span> to perform the sliding animation. The parameters are the board data structure, the direction of the slide, a message to display while sliding the tile, and the speed of the sliding.</p>
	<p>After it returns, we need to update the actual board data structure (which is done by the <span class="mono">makeMove()</span> function) and then add the slide to the <span class="mono">allMoves</span> list of all the slides made so far. This is done so that if the player clicks on the “Reset” button, we know how to undo all the player’s slides.</p>

	<h1 class="subheading" id="terminating-pygame">IDLE and Terminating Pygame Programs</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">117.</span> def terminate():</p>
		<p class="noindent mono"><span class="line-number">118.</span>     pygame.quit()</p>
		<p class="noindent mono"><span class="line-number">119.</span>     sys.exit()</p>
	</div>

	<p>This is a function that we can call that calls both the <span class="mono">pygame.quit()</span> and <span class="mono">sys.exit()</span> functions. This is a bit of syntactic sugar, so that instead of remembering to make both of these calls, there is just a single function we can call instead.</p>

	<h1 class="subheading" id="checking-specific-event">Checking for a Specific Event, and Posting Events to Pygame’s Event Queue</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">122.</span> def checkForQuit():</p>
		<p class="noindent mono"><span class="line-number">123.</span>     for event in pygame.event.get(QUIT): <span class="comment"># get all the QUIT events</span></p>
		<p class="noindent mono"><span class="line-number">124.</span>         terminate() <span class="comment"># terminate if any QUIT events are present</span></p>
		<p class="noindent mono"><span class="line-number">125.</span>     for event in pygame.event.get(KEYUP): <span class="comment"># get all the KEYUP events</span></p>
		<p class="noindent mono"><span class="line-number">126.</span>         if event.key == K_ESCAPE:</p>
		<p class="noindent mono"><span class="line-number">127.</span>             terminate() <span class="comment"># terminate if the KEYUP event was for the Esc key</span></p>
		<p class="noindent mono"><span class="line-number">128.</span>         pygame.event.post(event) <span class="comment"># put the other KEYUP event objects back</span></p>
	</div>

	<p>The <span class="mono">checkForQuit()</span> function will check for <span class="mono">QUIT</span> events (or if the user has pressed the Esc key) and then call the <span class="mono">terminate()</span> function. But this is a bit tricky and requires some explanation.</p>
	<p>Pygame internally has its own list data structure that it creates and appends Event objects to as they are made. This data structure is called the <a href="glossary.xhtml#event-queue"><b>event queue</b></a>. When the <span class="mono">pygame.event.get()</span> function is called with no parameters, the entire list is returned. However, you can pass a constant like <span class="mono">QUIT</span> to <span class="mono">pygame.event.get()</span> so that it will only return the <span class="mono">QUIT</span> events (if any) that are in the internal event queue. The rest of the events will stay in the event queue for the next time <span class="mono">pygame.event.get()</span> is called.</p>
	<p>You should note that Pygame’s event queue only stores up to 127 Event objects. If your program does not call <span class="mono">pygame.event.get()</span> frequently enough and the queue fills up, then any new events that happen won’t be added to the event queue.</p>
	<p>Line 123 pulls out a list of <span class="mono">QUIT</span> events from Pygame’s event queue and returns them. If there are any <span class="mono">QUIT</span> events in the event queue, the program terminates.</p>
	<p>Line 125 pulls out all the <span class="mono">KEYUP</span> events from the event queue and checks if any of them are for the Esc key. If one of the events is, then the program terminates. However, there could be <span class="mono">KEYUP</span> events for keys other than the Esc key. In this case, we need to put the <span class="mono">KEYUP</span> event back into Pygame’s event queue. We can do this with the <span class="mono">pygame.event.post()</span> function, which adds the Event object passed to it to the end of the Pygame event queue. This way, when line 70 calls <span class="mono">pygame.event.get()</span> the non-Esc key <span class="mono">KEYUP</span> events will still be there. Otherwise calls to <span class="mono">checkForQuit()</span> would “consume” all of the <span class="mono">KEYUP</span> events and those events would never be handled.</p>
	<p>The <span class="mono">pygame.event.post()</span> function is also handy if you ever want your program to add Event objects to the Pygame event queue.</p>

	<h1 class="subheading" id="creating-board-structure">Creating the Board Data Structure</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">131.</span> def getStartingBoard():</p>
		<p class="noindent mono"><span class="line-number">132.</span> &#160;&#160;&#160;&#160;<span class="comment"># Return a board data structure with tiles in the solved state.</span></p>
		<p class="noindent mono"><span class="line-number">133.</span> &#160;&#160;&#160;&#160;<span class="comment"># For example, if BOARDWIDTH and BOARDHEIGHT are both 3, this function</span></p>
		<p class="noindent mono"><span class="line-number">134.</span> &#160;&#160;&#160;&#160;<span class="comment"># returns [[1, 4, 7], [2, 5, 8], [3, 6, None]]</span></p>
		<p class="noindent mono"><span class="line-number">135.</span>     counter = 1</p>
		<p class="noindent mono"><span class="line-number">136.</span>     board = []</p>
		<p class="noindent mono"><span class="line-number">137.</span>     for x in range(BOARDWIDTH):</p>
		<p class="noindent mono"><span class="line-number">138.</span>         column = []</p>
		<p class="noindent mono"><span class="line-number">139.</span>         for y in range(BOARDHEIGHT):</p>
		<p class="noindent mono"><span class="line-number">140.</span>             column.append(counter)</p>
		<p class="noindent mono"><span class="line-number">141.</span>             counter += BOARDWIDTH</p>
		<p class="noindent mono"><span class="line-number">142.</span>         board.append(column)</p>
		<p class="noindent mono"><span class="line-number">143.</span>         counter -= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1</p>
		<p class="noindent mono"><span class="line-number">144.</span></p>
		<p class="noindent mono"><span class="line-number">145.</span>     board[BOARDWIDTH-1][BOARDHEIGHT-1] = None</p>
		<p class="noindent mono"><span class="line-number">146.</span>     return board</p>
	</div>

	<p>The <span class="mono">getStartingBoard()</span> data structure will create and return a data structure that represents a “solved” board, where all the numbered tiles are in order and the blank tile is in the lower right corner. This is done with nested <span class="mono">for</span> loops, just like the board data structure in the Memory Puzzle game was made.</p>
	<p>However, notice that the first column isn’t going to be <span class="mono">[1, 2, 3]</span> but instead <span class="mono">[1, 4, 7]</span>. This is because the numbers on the tiles increase by 1 going across the row, not down the column. Going down the column, the numbers increase by the size of the board’s width (which is stored in the <span class="mono">BOARDWIDTH</span> constant). We will use the <span class="mono">counter</span> variable to keep track of the number that should go on the next tile. When the numbering of the tiles in the column is finished, then we need to set <span class="mono">counter</span> to the number at the start of the next column. </p>

	<h1 class="subheading" id="not-tracking-blank">Not Tracking the Blank Position</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">149.</span> def getBlankPosition(board):</p>
		<p class="noindent mono"><span class="line-number">150.</span> &#160;&#160;&#160;&#160;<span class="comment"># Return the x and y of board coordinates of the blank space.</span></p>
		<p class="noindent mono"><span class="line-number">151.</span>     for x in range(BOARDWIDTH):</p>
		<p class="noindent mono"><span class="line-number">152.</span>         for y in range(BOARDHEIGHT):</p>
		<p class="noindent mono"><span class="line-number">153.</span>             if board[x][y] == None:</p>
		<p class="noindent mono"><span class="line-number">154.</span>                 return (x, y)</p>
	</div>

	<p>Whenever our code needs to find the XY coordinates of the blank space, instead of keeping track of where the blank space is after each slide, we can just create a function that goes through the entire board and finds the blank space coordinates. The <span class="mono">None</span> value is used in the board data structure to represent the blank space. The code in <span class="mono">getBlankPosition()</span> simply uses nested <span class="mono">for</span> loops to find which space on the board is the blank space.</p>

	<h1 class="subheading" id="updating-board-structure">Making a Move by Updating the Board Data Structure</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">157.</span> def makeMove(board, move):</p>
		<p class="noindent mono"><span class="line-number">158.</span> &#160;&#160;&#160;&#160;<span class="comment"># This function does not check if the move is valid.</span></p>
		<p class="noindent mono"><span class="line-number">159.</span>     blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">160.</span></p>
		<p class="noindent mono"><span class="line-number">161.</span>     if move == UP:</p>
		<p class="noindent mono"><span class="line-number">162.</span>         board[blankx][blanky], board[blankx][blanky + 1] = board[blankx][blanky + 1], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">163.</span>     elif move == DOWN:</p>
		<p class="noindent mono"><span class="line-number">164.</span>         board[blankx][blanky], board[blankx][blanky - 1] = board[blankx][blanky - 1], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">165.</span>     elif move == LEFT:</p>
		<p class="noindent mono"><span class="line-number">166.</span>         board[blankx][blanky], board[blankx + 1][blanky] = board[blankx + 1][blanky], board[blankx][blanky]</p>
		<p class="noindent mono"><span class="line-number">167.</span>     elif move == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">168.</span>         board[blankx][blanky], board[blankx - 1][blanky] = board[blankx - 1][blanky], board[blankx][blanky]</p>
	</div>

	<p>The data structure in the board parameter is a 2D list that represents where all the tiles are. Whenever the player makes a move, the program needs to update this data structure. What happens is that the value for the tile is swapped with the value for the blank space.</p>
	<p>The <span class="mono">makeMove()</span> function doesn’t have to return any values, because the <span class="mono">board</span> parameter has a list reference passed for its argument. This means that any changes we make to <span class="mono">board</span> in this function will be made to the list value that was passed to <span class="mono">makeMove()</span>. (You can review the concept of references at <a href="https://invpy.com/references">https://invpy.com/references</a>.)</p>

	<h1 class="subheading" id="when-not-assertion">When NOT to Use an Assertion</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">171.</span> def isValidMove(board, move):</p>
		<p class="noindent mono"><span class="line-number">172.</span>     blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">173.</span>     return (move == UP and blanky != len(board[0]) - 1) or \</p>
		<p class="noindent mono"><span class="line-number">174.</span>            (move == DOWN and blanky != 0) or \</p>
		<p class="noindent mono"><span class="line-number">175.</span>            (move == LEFT and blankx != len(board) - 1) or \</p>
		<p class="noindent mono"><span class="line-number">176.</span>            (move == RIGHT and blankx != 0)</p>
	</div>

	<p>The <span class="mono">isValidMove()</span> function is passed a board data structure and a move the player would want to make. The return value is <span class="mono">True</span> if this move is possible and <span class="mono">False</span> if it is not. For example, you cannot slide a tile to the left one hundred times in a row, because eventually the blank space will be at the edge and there are no more tiles to slide to the left.</p>
	<p>Whether a move is valid or not depends on where the blank space is. This function makes a call to <span class="mono">getBlankPosition()</span> to find the X and Y coordinates of the blank spot. Lines 173 to 176 are a <span class="mono">return</span> statement with a single expression. The <span class="mono">\</span> slashes at the end of the first three lines tells the Python interpreter that that is not the end of the line of code (even though it is at the end of the line). This will let us split up a “line of code” across multiple lines to look pretty, rather than just have one very long unreadable line.</p>
	<p>Because the parts of this expression in parentheses are joined by or operators, only one of them needs to be <span class="mono">True</span> for the entire expression to be <span class="mono">True</span>. Each of these parts checks what the intended move is and then sees if the coordinate of the blank space allows that move.</p>

	<h1 class="subheading" id="a-random-move">Getting a Not-So-Random Move</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">179.</span> def getRandomMove(board, lastMove=None):</p>
		<p class="noindent mono"><span class="line-number">180.</span> &#160;&#160;&#160;&#160;<span class="comment"># start with a full list of all four moves</span></p>
		<p class="noindent mono"><span class="line-number">181.</span>     validMoves = [UP, DOWN, LEFT, RIGHT]</p>
		<p class="noindent mono"><span class="line-number">182.</span></p>
		<p class="noindent mono"><span class="line-number">183.</span> &#160;&#160;&#160;&#160;<span class="comment"># remove moves from the list as they are disqualified</span></p>
		<p class="noindent mono"><span class="line-number">184.</span>     if lastMove == UP or not isValidMove(board, DOWN):</p>
		<p class="noindent mono"><span class="line-number">185.</span>         validMoves.remove(DOWN)</p>
		<p class="noindent mono"><span class="line-number">186.</span>     if lastMove == DOWN or not isValidMove(board, UP):</p>
		<p class="noindent mono"><span class="line-number">187.</span>         validMoves.remove(UP)</p>
		<p class="noindent mono"><span class="line-number">188.</span>     if lastMove == LEFT or not isValidMove(board, RIGHT):</p>
		<p class="noindent mono"><span class="line-number">189.</span>         validMoves.remove(RIGHT)</p>
		<p class="noindent mono"><span class="line-number">190.</span>     if lastMove == RIGHT or not isValidMove(board, LEFT):</p>
		<p class="noindent mono"><span class="line-number">191.</span>         validMoves.remove(LEFT)</p>
		<p class="noindent mono"><span class="line-number">192.</span></p>
		<p class="noindent mono"><span class="line-number">193.</span> &#160;&#160;&#160;&#160;<span class="comment"># return a random move from the list of remaining moves</span></p>
		<p class="noindent mono"><span class="line-number">194.</span>     return random.choice(validMoves)</p>
	</div>

	<p>At the beginning of the game, we start with the board data structure in the solved, ordered state and create the puzzle by randomly sliding around tiles. To decide which of the four directions we should slide, we’ll call our <span class="mono">getRandomMove()</span> function. Normally we could just use the <span class="mono">random.choice()</span> function and pass it a tuple <span class="mono">(UP, DOWN, LEFT, RIGHT)</span> to have Python simply randomly choose a direction value for us. But the Sliding Puzzle game has a small restriction that prevents us from choosing a purely random number.</p>
	<p>If you had a slide puzzle and slid a tile to left, and then slid a tile to the right, you would end up with the exact same board you had at the start. It’s pointless to make a slide followed by the opposite slide. Also, if the blank space is in the lower right corner than it is impossible to slide a tile up or to the left.</p>
	<p>The code in <span class="mono">getRandomMove()</span> will take these factors into account. To prevent the function from selecting the last move that was made, the caller of the function can pass a directional value for the <span class="mono">lastMove</span> parameter. Line 181 starts with a list of all four directional values stored in the <span class="mono">validMoves</span> variable. The <span class="mono">lastMove</span> value (if not set to <span class="mono">None</span>) is removed from <span class="mono">validMoves</span>. Depending on if the blank space is at the edge of the board, lines 184 to 191 will remove other directional values from the <span class="mono">lastMove</span> list.</p>
	<p>Of the values that are left in <span class="mono">lastMove</span>, one of them is randomly selected with a call to <span class="mono">random.choice()</span> and returned.</p>

	<h1 class="subheading" id="tile-to-pixel">Converting Tile Coordinates to Pixel Coordinates</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">197.</span> def getLeftTopOfTile(tileX, tileY):</p>
		<p class="noindent mono"><span class="line-number">198.</span>     left = XMARGIN + (tileX * TILESIZE) + (tileX - 1)</p>
		<p class="noindent mono"><span class="line-number">199.</span>     top = YMARGIN + (tileY * TILESIZE) + (tileY - 1)</p>
		<p class="noindent mono"><span class="line-number">200.</span>     return (left, top)</p>
	</div>

	<p>The <span class="mono">getLeftTopOfTile()</span> function converts board coordinates to pixel coordinates. For the board XY coordinates that are passed in, the function calculates and returns the pixel XY coordinates of the pixel at the top left of that board space.</p>

	<h1 class="subheading" id="pixel-to-board">Converting from Pixel Coordinates to Board Coordinates</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">203.</span> def getSpotClicked(board, x, y):</p>
		<p class="noindent mono"><span class="line-number">204.</span> &#160;&#160;&#160;&#160;<span class="comment"># from the x &amp; y pixel coordinates, get the x &amp; y board coordinates</span></p>
		<p class="noindent mono"><span class="line-number">205.</span>     for tileX in range(len(board)):</p>
		<p class="noindent mono"><span class="line-number">206.</span>         for tileY in range(len(board[0])):</p>
		<p class="noindent mono"><span class="line-number">207.</span>             left, top = getLeftTopOfTile(tileX, tileY)</p>
		<p class="noindent mono"><span class="line-number">208.</span>             tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE)</p>
		<p class="noindent mono"><span class="line-number">209.</span>             if tileRect.collidepoint(x, y):</p>
		<p class="noindent mono"><span class="line-number">210.</span>                 return (tileX, tileY)</p>
		<p class="noindent mono"><span class="line-number">211.</span>     return (None, None)</p>
	</div>

	<p>The <span class="mono">getSpotClicked()</span> function does the opposite of <span class="mono">getLeftTopOfTile()</span> and converts from pixel coordinates to board coordinates. The nested loops on lines 205 and 206 go through every possible XY board coordinate, and if the pixel coordinates that were passed in are within that space on the board, it returns those board coordinates. Since all of the tiles have a width and height that is set in the <span class="mono">TILESIZE</span> constant, we can create a Rect object that represents the space on the board by getting the pixel coordinates of the top left corner of the board space, and then use the <span class="mono">collidepoint()</span> Rect method to see if the pixel coordinates are inside that Rect object’s area.</p>

	<p>If the pixel coordinates that were passed in were not over any board space, then the value <span class="mono">(None, None)</span> is returned.</p>

	<h1 class="subheading" id="drawing-a-tile">Drawing a Tile</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">214.</span> def drawTile(tilex, tiley, number, adjx=0, adjy=0):</p>
		<p class="noindent mono"><span class="line-number">215.</span> &#160;&#160;&#160;&#160;<span class="comment"># draw a tile at board coordinates tilex and tiley, optionally a few</span></p>
		<p class="noindent mono"><span class="line-number">216.</span> &#160;&#160;&#160;&#160;<span class="comment"># pixels over (determined by adjx and adjy)</span></p>
		<p class="noindent mono"><span class="line-number">217.</span>     left, top = getLeftTopOfTile(tilex, tiley)</p>
		<p class="noindent mono"><span class="line-number">218.</span>     pygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, TILESIZE, TILESIZE))</p>
		<p class="noindent mono"><span class="line-number">219.</span>     textSurf = BASICFONT.render(str(number), True, TEXTCOLOR)</p>
		<p class="noindent mono"><span class="line-number">220.</span>     textRect = textSurf.get_rect()</p>
		<p class="noindent mono"><span class="line-number">221.</span>     textRect.center = left + int(TILESIZE / 2) + adjx, top + int(TILESIZE / 2) + adjy</p>
		<p class="noindent mono"><span class="line-number">222.</span>     DISPLAYSURF.blit(textSurf, textRect)</p>
	</div>

<p>The <span class="mono">drawTile()</span> function will draw
a single numbered tile on the board. The <span class="mono">tilex</span> and <span
class="mono">tiley</span> parameters are the board coordinates of the tile.
The number parameter is a string of the tile’s number (like <span
class="mono">'3'</span> or <span class="mono">'12'</span>). The <span
class="mono">adjx</span> and <span class="mono">adjy</span> keyword
parameters are for making minor adjustments to the position of the tile. For
example, passing <span class="mono">5</span> for <span class="mono">adjx</span>
would make the tile appear 5 pixels to the right of the <span class="mono">tilex</span>
and <span class="mono">tiley</span> space on the board. Passing <span
class="mono">-10</span> for <span class="mono">adjx</span> would make the
tile appear 10 pixels to the left of the space. </p>

<p>These adjustment values will be handy when we need to draw
the tile in the middle of sliding. If no values are passed for these arguments
when <span class="mono">drawTile()</span> is called, then by default they are
set to <span class="mono">0</span>. This means they will be exactly on the
board space given by <span class="mono">tilex</span> and <span class="mono">tiley</span>.
</p>

<p>The Pygame drawing functions only use pixel coordinates, so
first line 217 converts the board coordinates in <span class="mono">tilex</span>
and <span class="mono">tiley</span> to pixel coordinates, which we will store
in variables <span class="mono">left</span> and <span class="mono">top</span>
(since <span class="mono">getLeftTopOfTile()</span> returns the top left
corner’s coordinates). We draw the background square of the tile with a call to
<span class="mono">pygame.draw.rect()</span> while adding the <span
class="mono">adjx</span> and <span class="mono">adjy</span> values to <span
class="mono">left</span> and <span class="mono">top</span> in case the code
needs to adjust the position of the tile.</p>

<p>Lines 219 to 222 then create the Surface object that has the
number text drawn on it. A Rect object for the Surface object is positioned,
and then used to blit the Surface object to the display Surface. The <span
class="mono">drawTile()</span> function doesn’t call <span class="mono">pygame.display.update()</span>
function, since the caller of <span class="mono">drawTile()</span> probably
will want to draw more tiles for the rest of the board before making them
appear on the screen.</p>

	<h1 class="subheading" id="making-text-appear">The Making Text Appear on the Screen</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">225.</span> def
makeText(text, color, bgcolor, top, left):</p>
		<p class="noindent mono"><span class="line-number">226.</span> &#160;&#160;&#160;&#160;<span
class="comment"># create the Surface and Rect objects for some text.</span></p>
		<p class="noindent mono"><span class="line-number">227.</span>     textSurf
= BASICFONT.render(text, True, color, bgcolor)</p>
		<p class="noindent mono"><span class="line-number">228.</span>     textRect
= textSurf.get_rect()</p>
		<p class="noindent mono"><span class="line-number">229.</span>     textRect.topleft
= (top, left)</p>
		<p class="noindent mono"><span class="line-number">230.</span>     return
(textSurf, textRect)</p>
	</div>

<p>The <span class="mono">makeText()</span> function handles
creating the Surface and Rect objects for positioning text on the screen.
Instead of doing all these calls each time we want to make text on the screen,
we can just call <span class="mono">makeText()</span> instead. This saves us
on the amount of typing we have to do for our program. (Though <span
class="mono">drawTile()</span> makes the calls to <span class="mono">render()</span>
and <span class="mono">get_rect()</span> itself because it positions the text
Surface object by the center point rather than the topleft point and uses a
transparent background color.)</p>

<h1 class="subheading" id="drawing-the-board">Drawing the Board</h1>

<div class="python-shell">

		<p class="noindent mono"><span class="line-number">233.</span> def
drawBoard(board, message):</p>

		<p class="noindent mono"><span class="line-number">234.</span>     DISPLAYSURF.fill(BGCOLOR)</p>

		<p class="noindent mono"><span class="line-number">235.</span>     if
message:</p>

		<p class="noindent mono"><span class="line-number">236.</span>         textSurf,
textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, 5)</p>

		<p class="noindent mono"><span class="line-number">237.</span>         DISPLAYSURF.blit(textSurf,
textRect)</p>

		<p class="noindent mono"><span class="line-number">238.</span></p>

		<p class="noindent mono"><span class="line-number">239.</span>     for
tilex in range(len(board)):</p>

		<p class="noindent mono"><span class="line-number">240.</span>         for
tiley in range(len(board[0])):</p>

		<p class="noindent mono"><span class="line-number">241.</span>             if
board[tilex][tiley]:</p>

		<p class="noindent mono"><span class="line-number">242.</span>                 drawTile(tilex,
tiley, board[tilex][tiley])</p>

</div>

<p>This function handles drawing the entire board and all of
its tiles to the <span class="mono">DISPLAYSURF</span> display Surface object.
The <span class="mono">fill()</span> method on line 234 completely paints over
anything that used to be drawn on the display Surface object before so that we
start from scratch.</p>

<p>Line 235 to 237 handles drawing the message at the top of
the window. We use this for the “Generating new puzzle…” and other text we want
to display at the top of the window. Remember that <span class="mono">if</span>
statement conditions consider the blank string to be a <span class="mono">False</span>
value, so if message is set to <span class="mono">''</span> then the condition
is <span class="mono">False</span> and lines 236 and 237 are skipped.</p>

	<p>Next, nested <span class="mono">for</span> loops are used to draw each tile to the display Surface object by calling the <span class="mono">drawTile()</span> function.</p>

	<h1 class="subheading" id="drawing-border-board">Drawing the Border of the Board</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">244.</span>     left, top = getLeftTopOfTile(0, 0)</p>
		<p class="noindent mono"><span class="line-number">245.</span>     width = BOARDWIDTH * TILESIZE</p>
		<p class="noindent mono"><span class="line-number">246.</span>     height = BOARDHEIGHT * TILESIZE</p>
		<p class="noindent mono"><span class="line-number">247.</span>     pygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + 11, height + 11), 4)</p>
	</div>

	<p>Lines 244 to 247 draw a border around the tiles. The top left corner of the boarder will be 5 pixels to the left and 5 pixels above the top left corner of the tile at board coordinates (0, 0). The width and height of the border are calculated from the number of tiles wide and high the board is (stored in the <span class="mono">BOARDWIDTH</span> and <span class="mono">BOARDHEIGHT</span> constants) multiplied by the size of the tiles (stored in the <span class="mono">TILESIZE</span> constant).</p>
	<p>The rectangle we draw on line 247 will have a thickness of 4 pixels, so we will move the boarder 5 pixels to the left and above where the <span class="mono">top</span> and <span class="mono">left</span> variables point so the thickness of the line won’t overlap the tiles. We will also add <span class="mono">11</span> to the width and length (5 of those 11 pixels are to compensate for moving the rectangle to the left and up).</p>

	<h1 class="subheading" id="drawing-the-buttons">Drawing the Buttons</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">249.</span>     DISPLAYSURF.blit(RESET_SURF, RESET_RECT)</p>
		<p class="noindent mono"><span class="line-number">250.</span>     DISPLAYSURF.blit(NEW_SURF, NEW_RECT)</p>
		<p class="noindent mono"><span class="line-number">251.</span>     DISPLAYSURF.blit(SOLVE_SURF, SOLVE_RECT)</p>
	</div>

	<p>Finally, we draw the buttons off to the slide of the screen. The text and position of these buttons never changes, which is why they were stored in constant variables at the beginning of the <span class="mono">main()</span> function.</p>

	<h1 class="subheading" id="animating-tile-slides">Animating the Tile Slides</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">254.</span> def slideAnimation(board, direction, message, animationSpeed):</p>
		<p class="noindent mono"><span class="line-number">255.</span> &#160;&#160;&#160;&#160;<span class="comment"># Note: This function does not check if the move is valid.</span></p>
		<p class="noindent mono"><span class="line-number">256.</span></p>
		<p class="noindent mono"><span class="line-number">257.</span> &#160;&#160;&#160;&#160;blankx, blanky = getBlankPosition(board)</p>
		<p class="noindent mono"><span class="line-number">258.</span> &#160;&#160;&#160;&#160;if direction == UP:</p>
		<p class="noindent mono"><span class="line-number">259.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx</p>
		<p class="noindent mono"><span class="line-number">260.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky + 1</p>
		<p class="noindent mono"><span class="line-number">261.</span> &#160;&#160;&#160;&#160;elif direction == DOWN:</p>
		<p class="noindent mono"><span class="line-number">262.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx</p>
		<p class="noindent mono"><span class="line-number">263.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky - 1</p>
		<p class="noindent mono"><span class="line-number">264.</span> &#160;&#160;&#160;&#160;elif direction == LEFT:</p>
		<p class="noindent mono"><span class="line-number">265.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx + 1</p>
		<p class="noindent mono"><span class="line-number">266.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky</p>
		<p class="noindent mono"><span class="line-number">267.</span> &#160;&#160;&#160;&#160;elif direction == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">268.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movex = blankx - 1</p>
		<p class="noindent mono"><span class="line-number">269.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;movey = blanky</p>
	</div>

	<p>The first thing our tile sliding animation code needs to calculate is where the blank space is and where the moving tile is. The comment on line 255 reminds us that the code that calls <span class="mono">slideAnimation()</span> should make sure that the slide it passes for the direction parameter is a valid move to make.</p>
	<p>The blank space’s coordinates come from a call to <span class="mono">getBlankPosition()</span>. From these coordinates and the direction of the slide, we can figure out the XY board coordinates of the tile that will slide. These coordinates will be stored in the <span class="mono">movex</span> and <span class="mono">movey</span> variables.</p>

	<h1 class="subheading" id="copy-surface-method">The <span class="mono">copy()</span> Surface Method</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">271.</span> &#160;&#160;&#160;&#160;<span class="comment"># prepare the base surface</span></p>
		<p class="noindent mono"><span class="line-number">272.</span> &#160;&#160;&#160;&#160;drawBoard(board, message)</p>
		<p class="noindent mono"><span class="line-number">273.</span> &#160;&#160;&#160;&#160;baseSurf = DISPLAYSURF.copy()</p>
		<p class="noindent mono"><span class="line-number">274.</span> &#160;&#160;&#160;&#160;<span class="comment"># draw a blank space over the moving tile on the baseSurf Surface.</span></p>
		<p class="noindent mono"><span class="line-number">275.</span> &#160;&#160;&#160;&#160;moveLeft, moveTop = getLeftTopOfTile(movex, movey)</p>
		<p class="noindent mono"><span class="line-number">276.</span> &#160;&#160;&#160;&#160;pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))</p>
	</div>

<p>The <span class="mono">copy()</span> method of Surface objects will return a new Surface object that has the same image drawn to it. But they are two separate Surface objects. After calling the <span class="mono">copy()</span> method, if we draw on one Surface object using <span class="mono">blit()</span> or the Pygame drawing functions, it will not change the image on the other Surface object. We store this copy in the <span class="mono">baseSurf</span> variable on line 273.</p>
<p>Next, we paint another blank space over the tile that will slide. This is because when we draw each frame of the sliding animation, we will draw the sliding tile over different parts of the <span class="mono">baseSurf</span> Surface object. If we didn’t blank out the moving tile on the <span class="mono">baseSurf</span> Surface, then it would still be there as we draw the sliding tile. In that case, here is what the <span class="mono">baseSurf</span> Surface would look like:</p>
<p>And then what it would look like when we draw the “9” tile sliding upwards on top of it:</p>
<p>You can see this for yourself by commenting out line 276 and running the program.</p>

<div class="python-shell">
		<p class="noindent mono"><span class="line-number">278.</span> &#160;&#160;&#160;&#160;for i in range(0, TILESIZE, animationSpeed):</p>
		<p class="noindent mono"><span class="line-number">279.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="comment"># animate the tile sliding over</span></p>
		<p class="noindent mono"><span class="line-number">280.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;checkForQuit()</p>
		<p class="noindent mono"><span class="line-number">281.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DISPLAYSURF.blit(baseSurf, (0, 0))</p>
		<p class="noindent mono"><span class="line-number">282.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == UP:</p>
		<p class="noindent mono"><span class="line-number">283.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], 0, -i)</p>
		<p class="noindent mono"><span class="line-number">284.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == DOWN:</p>
		<p class="noindent mono"><span class="line-number">285.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], 0, i)</p>
		<p class="noindent mono"><span class="line-number">286.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == LEFT:</p>
		<p class="noindent mono"><span class="line-number">287.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], -i, 0)</p>
		<p class="noindent mono"><span class="line-number">288.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if direction == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">289.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drawTile(movex, movey, board[movex][movey], i, 0)</p>
		<p class="noindent mono"><span class="line-number">290.</span></p>
		<p class="noindent mono"><span class="line-number">291.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">292.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FPSCLOCK.tick(FPS)</p>
	</div>

	<p>In order to draw the frames of the sliding animation, we must draw the <span class="mono">baseSurf</span> surface on the display Surface, then on each frame of the animation draw the sliding tile closer and closer to its final position where the original blank space was. The space between two adjacent tiles is the same size as a single tile, which we have stored in <span class="mono">TILESIZE</span>. The code uses a <span class="mono">for</span> loop to go from <span class="mono">0</span> to <span class="mono">TILESIZE</span>.</p>
	<p>Normally this would mean that we would draw the tile 0 pixels over, then on the next frame draw the tile 1 pixel over, then 2 pixels, then 3, and so on. Each of these frames would take 1/30<sup>th</sup> of a second. If you have <span class="mono">TILESIZE</span> set to <span class="mono">80</span> (as the program in this book does on line 12) then sliding a tile would take over two and a half seconds, which is actually kind of slow.</p>
	<p>So instead we will have the <span class="mono">for</span> loop iterate from <span class="mono">0</span> to <span class="mono">TILESIZE</span> by several pixels each frame. The number of pixels it jumps over is stored in <span class="mono">animationSpeed</span>, which is passed in when <span class="mono">slideAnimation()</span> is called. For example, if <span class="mono">animationSpeed</span> was set to <span class="mono">8</span> and the constant <span class="mono">TILESIZE</span> was set to <span class="mono">80</span>, then the <span class="mono">for</span> loop and <span class="mono">range(0, TILESIZE, animationSpeed)</span> would set the <span class="mono">i</span> variable to the values <span class="mono">0</span>, <span class="mono">8</span>, <span class="mono">16</span>, <span class="mono">24</span>, <span class="mono">32</span>, <span class="mono">40</span>, <span class="mono">48</span>, <span class="mono">56</span>, <span class="mono">64</span>, <span class="mono">72</span>. (It does not include <span class="mono">80</span> because the <span class="mono">range()</span> function goes up to, but not including, the second argument.) This means the entire sliding animation would be done in 10 frames, which would mean it is done in 10/30<sup>th</sup> of a second (a third of a second) since the game runs at 30 FPS.</p>
	<p>Lines 282 to 289 makes sure that we draw the tile sliding in the correct direction (based on what value the <span class="mono">direction</span> variable has). After the animation is done, then the function returns. Notice that while the animation is happening, any events being created by the user are not being handled. Those events will be handled the next time execution reaches line 70 in the <span class="mono">main()</span> function or the code in the <span class="mono">checkForQuit()</span> function.</p>

	<h1 class="subheading" id="create-new-puzzle">Creating a New Puzzle</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">295.</span> def generateNewPuzzle(numSlides):</p>
		<p class="noindent mono"><span class="line-number">296.</span> &#160;&#160;&#160;&#160;<span class="comment"># From a starting configuration, make numSlides number of moves (and</span></p>
		<p class="noindent mono"><span class="line-number">297.</span> &#160;&#160;&#160;&#160;<span class="comment"># animate these moves).</span></p>
		<p class="noindent mono"><span class="line-number">298.</span> &#160;&#160;&#160;&#160;sequence = []</p>
		<p class="noindent mono"><span class="line-number">299.</span> &#160;&#160;&#160;&#160;board = getStartingBoard()</p>
		<p class="noindent mono"><span class="line-number">300.</span> &#160;&#160;&#160;&#160;drawBoard(board, '')</p>
		<p class="noindent mono"><span class="line-number">301.</span> &#160;&#160;&#160;&#160;pygame.display.update()</p>
		<p class="noindent mono"><span class="line-number">302.</span> &#160;&#160;&#160;&#160;pygame.time.wait(500) <span class="comment"># pause 500 milliseconds for effect</span></p>
	</div>

	<p>The <span class="mono">generateNewPuzzle()</span> function will be called at the start of each new game. It will create a new board data structure by calling <span class="mono">getStartingBoard()</span> and then randomly scramble it. The first few lines of <span class="mono">generateNewPuzzle()</span> get the board and then draw it to the screen (freezing for half a second to let the player see the fresh board for a moment).</p>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">303.</span> &#160;&#160;&#160;&#160;lastMove = None</p>
		<p class="noindent mono"><span class="line-number">304.</span> &#160;&#160;&#160;&#160;for i in range(numSlides):</p>
		<p class="noindent mono"><span class="line-number">305.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;move = getRandomMove(board, lastMove)</p>
		<p class="noindent mono"><span class="line-number">306.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideAnimation(board, move, 'Generating new puzzle...', int(TILESIZE / 3))</p>
		<p class="noindent mono"><span class="line-number">307.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;makeMove(board, move)</p>
		<p class="noindent mono"><span class="line-number">308.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sequence.append(move)</p>
		<p class="noindent mono"><span class="line-number">309.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastMove = move</p>
		<p class="noindent mono"><span class="line-number">310.</span> &#160;&#160;&#160;&#160;return (board, sequence)</p>
	</div>

	<p>The <span class="mono">numSlides</span> parameter will show tell the function how many of these random moves to make. The code for doing a random move is the <span class="mono">getRandomMove()</span> call on line 305 to get the move itself, then call <span class="mono">slideAnimation()</span> to perform the animation on the screen. Because doing the slide animation does not actually update the board data structure, we update the board by calling <span class="mono">makeMove()</span> on line 307.</p>
	<p>We need to keep track of each of the random moves that was made so that the player can click the “Solve” button later and have the program undo all these random moves. (The “<a href="chapter4.xhtml#stupid-code">Being Smart By Using Stupid Code</a>” section talks about why and how we do this.) So the move is appended to the list of moves in <span class="mono">sequence</span> on line 308.</p>
	<p>Then we store the random move in a variable called <span class="mono">lastMove</span> which will be passed to <span class="mono">getRandomMove()</span> on the next iteration. This prevents the next random move from undoing the random move we just performed.</p>
	<p>All of this needs to happen <span class="mono">numSlides</span> number of times, so we put lines 305 to 309 inside a <span class="mono">for</span> loop. When the board is done being scrambled, then we return the board data structure and also the list of the random moves made on it.</p>

	<h1 class="subheading" id="animating-board-reset">Animating the Board Reset</h1>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">313.</span> def resetAnimation(board, allMoves):</p>
		<p class="noindent mono"><span class="line-number">314.</span> &#160;&#160;&#160;&#160;<span class="comment"># make all of the moves in allMoves in reverse.</span></p>
		<p class="noindent mono"><span class="line-number">315.</span> &#160;&#160;&#160;&#160;revAllMoves = allMoves[:] <span class="comment"># gets a copy of the list</span></p>
		<p class="noindent mono"><span class="line-number">316.</span> &#160;&#160;&#160;&#160;revAllMoves.reverse()</p>
		<p class="noindent mono"><span class="line-number">317.</span></p>
		<p class="noindent mono"><span class="line-number">318.</span> &#160;&#160;&#160;&#160;for move in revAllMoves:</p>
		<p class="noindent mono"><span class="line-number">319.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if move == UP:</p>
		<p class="noindent mono"><span class="line-number">320.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = DOWN</p>
		<p class="noindent mono"><span class="line-number">321.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == DOWN:</p>
		<p class="noindent mono"><span class="line-number">322.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = UP</p>
		<p class="noindent mono"><span class="line-number">323.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == RIGHT:</p>
		<p class="noindent mono"><span class="line-number">324.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = LEFT</p>
		<p class="noindent mono"><span class="line-number">325.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif move == LEFT:</p>
		<p class="noindent mono"><span class="line-number">326.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;oppositeMove = RIGHT</p>
		<p class="noindent mono"><span class="line-number">327.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slideAnimation(board, oppositeMove, '', int(TILESIZE / 2))</p>
		<p class="noindent mono"><span class="line-number">328.</span> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;makeMove(board, oppositeMove)</p>
	</div>

	<p>When the player clicks on “Reset” or “Solve”, the Slide Puzzle game program needs to undo all of the moves that were made to the board. The list of directional values for the slides will be passed as the argument for the <span class="mono">allMoves</span> parameter.</p>
	<p>Line 315 uses list slicing to create a duplicate of the <span class="mono">allMoves</span> list. Remember that if you don’t specify a number before the <span class="mono">:</span>, then Python assumes the slice should start from the very beginning of the list. And if you don’t specify a number after the <span class="mono">:</span>, then Python assumes the slice should keep going to the very end of the list. So <span class="mono">allMoves[:]</span> creates a list slice of the entire <span class="mono">allMoves</span> list. This makes a copy of the actual list to store in <span class="mono">revAllMoves</span>, rather than just a copy of the list reference. (See <a href="https://invpy.com/references">https://invpy.com/references</a> for details.)</p>
	<p>To undo all the moves in <span class="mono">allMoves</span>, we need to perform the opposite move of the moves in <span class="mono">allMoves</span>, and in reverse order. There is a list method called <span class="mono">reverse()</span> which will reverse the order of the items in a list. We call this on the <span class="mono">revAllMoves</span> list on line 316.</p>
	<p>The <span class="mono">for</span> loop on line 318 iterates over the list of directional values. Remember, we want the opposite move, so the <span class="mono">if</span> and <span class="mono">elif</span> statements from line 319 to 326 set the correct directional value in the <span class="mono">oppositeMove</span> variable. Then we call <span class="mono">slideAnimation()</span> to perform the animation, and <span class="mono">makeMove()</span> to update the board data structure.</p>

	<div class="python-shell">
		<p class="noindent mono"><span class="line-number">331.</span> if __name__ == '__main__':</p>
		<p class="noindent mono"><span class="line-number">332.</span> &#160;&#160;&#160;&#160;main()</p>
	</div>

	<p>Just like in the Memory Puzzle game, after all the <span class="mono">def</span> statements have been executed to create all the functions, we call the <span class="mono">main()</span> function to begin the meat of the program.</p>
	<p>That’s all there is to the Slide Puzzle program! But let’s talk about some general programming concepts that came up in this game.</p>

	<h1 class="subheading" id="time-memory-tradeoffs">Time vs. Memory Tradeoffs</h1>
	<p class="noindent">Of course, there are a few different ways to write the Slide Puzzle game so that it looks and acts the exact same way even though the code is different. There are many different ways the a program that does a task could be written. The most common differences are making tradeoffs between execution time and memory usage.</p>
	<p>Usually, the faster a program can run, the better it is. This is especially true with programs that need to do a lot of calculations, whether they are scientific weather simulators or games with a large amount of detailed 3D graphics to draw. It’s also good to use the least amount of memory possible. The more variables and the larger the lists your program uses, the more memory it takes up. (You can find out how to measure your program’s memory usage and execution time at <a href="https://invpy.com/profiling">https://invpy.com/profiling</a>.)</p>
	<p>Right now, the programs in this book aren’t big and complicated enough where you have to worry about conserving memory or optimizing the execution time. But it can be something to consider as you become a more skilled programmer.</p>
	<p>For example, consider the <span class="mono">getBlankPosition()</span> function. This function takes time to run, since it goes through all the possible board coordinates to find where the blank space is. Instead, we could just have a <span class="mono">blankspacex</span> and <span class="mono">blankspacey</span> variable which would have these XY coordinates so we would not have to look through the entire board each time we want to know where it was. (We would also need code that updates the <span class="mono">blankspacex</span> and <span class="mono">blankspacey</span> variables whenever a move is done. This code could go in <span class="mono">makeMove()</span>.) Using these variables would take up more memory, but they would save you on execution time so your program would run faster.</p>
	<p>Another example is that we keep a board data structure in the solved state in the <span class="mono">SOLVEDBOARD</span> variable, so that we can compare the current board to <span class="mono">SOLVEDBOARD</span> to see if the player has solved the puzzle. Each time we wanted to do this check, we could just call the <span class="mono">getStartingBoard()</span> function and compare the returned value to the current board. Then we would not need the <span class="mono">SOLVEDBOARD</span> variable. This would save us a little bit of memory, but then our program would take longer to run because it is re-creating the solved-state board data structure each time we do this check.</p>
	<p>There is one thing you must remember though. Writing code that is readable is a very important skill. Code that is “readable” is code that is easy to understand, especially by programmers who did not write the code. If another programmer can look at your program’s source code and figure out what it does without much trouble, then that program is very readable. Readability is important because when you want to fix bugs or add new features to your program (and bugs and ideas for new features <b>always</b> come up), then having a readable program makes those tasks much easier.</p>

	<h1 class="subheading" id="few-bytes">Nobody Cares About a Few Bytes</h1>
	<p class="noindent">Also, there is one thing that might seem kind of silly to say in this book because it seem obvious, but many people wonder about it. You should know that using short variable names like <span class="mono">x</span> or <span class="mono">num</span> instead of longer, more descriptive variable names like <span class="mono">blankx</span> or <span class="mono">numSlides</span> does not save you any memory when your program actually runs. Using these longer variable names is better because they’ll make your program more readable.</p>
	<p>You might also come up with some clever tricks that do save a few bytes of memory here and there. One trick is that when you no longer need a variable, you can reuse that variable name for a different purpose instead of just using two differently named variables. </p>
	<p>Try to avoid the temptation to do this. Usually, these tricks reduce code readability and make it harder to debug your programs. Modern computers have billions of bytes of memory, and saving a few bytes here and there really isn’t worth making the code more confusing for human programmers.</p>

	<h1 class="subheading" id="few-nanoseconds">Nobody Cares About a Few Million Nanoseconds</h1>
	<p class="noindent">Similarly, there are times when you can rearrange your code in some way to make it slightly faster by a few nanoseconds. These tricks also usually make the code harder to read. When you consider that several billion nanoseconds have passed in the time it takes you to read this sentence, saving a few nanoseconds of execution time in your program won’t be noticed by the player.</p>

	<h1 class="subheading" id="summary">Summary</h1>
	<p class="noindent">This chapter hasn’t introduced any new Pygame programming concepts that the Memory Puzzle game didn’t use, aside from using the <span class="mono">copy()</span> method of Surface objects. Just knowing a few different concepts will let you create completely different games.</p>
	<p>For practice, you can download buggy versions of the Sliding Puzzle program from <a href="https://invpy.com/buggy/slidepuzzle">https://invpy.com/buggy/slidepuzzle</a>.</p>

</body>
</html>
